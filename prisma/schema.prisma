// VLN Database Schema
// Supports Phase 1 (v0.11.0), Phase 2 (v1.1.0-1.3.0), Phase 3 (v2.0.0-2.2.0)
// Last Updated: 2026-02-25

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============================================================================
// AUTHENTICATION & USER MANAGEMENT
// ============================================================================

model User {
  id                    String          @id @default(cuid())
  email                 String          @unique
  emailVerified         DateTime?
  name                  String?
  role                  UserRole        @default(CLIENT)
  passwordHash          String?
  twoFactorEnabled      Boolean         @default(false)
  twoFactorSecret       String?
  lastLogin             DateTime?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  // Relations
  sessions              Session[]
  verificationTokens    VerificationToken[]
  auditRequests         AuditRequest[]
  reports               Report[]
  payments              Payment[]
  invoices              Invoice[]
  teamMembers           TeamMember[]    @relation("user_team_members")
  teamLeadTeams         Team[]          @relation("team_lead")
  oauthAccounts         OAuthAccount[]
  notificationSettings  NotificationSettings?
  activityLogs          ActivityLog[]

  @@index([email])
  @@index([role])
  @@index([createdAt])
}

enum UserRole {
  ADMIN
  RESEARCHER
  MANAGER
  CLIENT
  GUEST
}

model Session {
  id            String          @id @default(cuid())
  userId        String
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  token         String          @unique
  refreshToken  String?
  expiresAt     DateTime
  ipAddress     String?
  userAgent     String?
  revokedAt     DateTime?
  createdAt     DateTime        @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model VerificationToken {
  id        String    @id @default(cuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String    @unique
  type      TokenType
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([token])
  @@index([type])
}

enum TokenType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
  TWO_FACTOR
  MAGIC_LINK
}

model OAuthAccount {
  id                String    @id @default(cuid())
  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider          String    // google, github, etc
  providerAccountId String
  accessToken       String?
  refreshToken      String?
  expiresAt         DateTime?
  createdAt         DateTime  @default(now())

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// ============================================================================
// TEAM & ORGANIZATION
// ============================================================================

model Team {
  id              String        @id @default(cuid())
  name            String
  slug            String        @unique
  description     String?
  leadId          String
  lead            User          @relation("team_lead", fields: [leadId], references: [id])
  logo            String?
  website         String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  members         TeamMember[]
  auditRequests   AuditRequest[]

  @@index([leadId])
  @@index([slug])
}

model TeamMember {
  id            String    @id @default(cuid())
  teamId        String
  team          Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
  userId        String
  user          User      @relation("user_team_members", fields: [userId], references: [id], onDelete: Cascade)
  role          TeamRole
  joinedAt      DateTime  @default(now())

  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
}

enum TeamRole {
  ADMIN
  MEMBER
  VIEWER
}

// ============================================================================
// AUDIT REQUESTS & INTAKE
// ============================================================================

model AuditRequest {
  id                  String            @id @default(cuid())
  userId              String
  user                User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId              String?
  team                Team?             @relation(fields: [teamId], references: [id], onDelete: SetNull)

  projectName         String
  description         String
  serviceType         AuditServiceType
  scope               String            // JSON: contract addresses, file paths, etc
  scopeSize           Int               // lines of code or contract count

  status              AuditStatus       @default(PENDING)
  priority            AuditPriority     @default(MEDIUM)
  assignedTo          String?           // researcher ID

  estimatedCost       Decimal           @default(0)
  actualCost          Decimal?

  startDate           DateTime?
  targetDate          DateTime?
  completionDate      DateTime?

  notes               String?
  internalNotes       String?

  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  deletedAt           DateTime?

  // Relations
  files               UploadedFile[]
  reports             Report[]
  findings            Finding[]
  payments            Payment[]
  notifications       Notification[]
  activityLogs        ActivityLog[]     @relation("audit_activity")

  @@index([userId])
  @@index([teamId])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
  @@index([assignedTo])
}

enum AuditStatus {
  PENDING
  INTAKE
  APPROVED
  IN_PROGRESS
  UNDER_REVIEW
  REPORT_GENERATION
  COMPLETED
  CANCELLED
}

enum AuditPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AuditServiceType {
  SMART_CONTRACT_AUDIT
  PLATFORM_SECURITY_AUDIT
  RNG_ANALYSIS
  WALLET_FLOW_RISK_ASSESSMENT
  API_SECURITY_REVIEW
  CUSTOM_ASSESSMENT
}

model UploadedFile {
  id              String        @id @default(cuid())
  auditId         String
  audit           AuditRequest  @relation(fields: [auditId], references: [id], onDelete: Cascade)

  filename        String
  originalName    String
  mimeType        String
  size            Int
  storagePath     String        // S3 or Vercel Blob path
  checksum        String        // For integrity verification

  uploadedBy      String
  uploadedAt      DateTime      @default(now())
  accessedAt      DateTime?

  @@index([auditId])
  @@index([uploadedAt])
}

// ============================================================================
// REPORTS & FINDINGS
// ============================================================================

model Report {
  id                String        @id @default(cuid())
  auditId           String
  audit             AuditRequest  @relation(fields: [auditId], references: [id], onDelete: Cascade)

  userId            String
  user              User          @relation(fields: [userId], references: [id])

  title             String
  summary           String
  executive         String?       // Executive summary
  methodology       String?
  scope             String?
  limitations       String?

  status            ReportStatus  @default(DRAFT)
  version           Int           @default(1)

  critical          Int           @default(0)
  high              Int           @default(0)
  medium            Int           @default(0)
  low               Int           @default(0)
  informational     Int           @default(0)

  pdfUrl            String?
  htmlContent       String?       // For interactive viewing

  signedAt          DateTime?
  reviewedAt        DateTime?
  publishedAt       DateTime?

  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  findings          Finding[]
  attachments       ReportAttachment[]

  @@index([auditId])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

enum ReportStatus {
  DRAFT
  REVIEW
  APPROVED
  PUBLISHED
  ARCHIVED
}

model Finding {
  id                String        @id @default(cuid())
  auditId           String
  audit             AuditRequest  @relation(fields: [auditId], references: [id], onDelete: Cascade)
  reportId          String
  report            Report        @relation(fields: [reportId], references: [id], onDelete: Cascade)

  title             String
  description       String
  impact            String?
  remediation       String?

  severity          Severity
  category          VulnerabilityCategory
  cwe               String?       // CWE identifier

  affectedCode      String?       // Line numbers or addresses
  proof             String?       // PoC or evidence

  status            FindingStatus @default(OPEN)
  resolution        String?
  resolvedAt        DateTime?

  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  @@index([auditId])
  @@index([reportId])
  @@index([severity])
  @@index([status])
}

enum Severity {
  CRITICAL
  HIGH
  MEDIUM
  LOW
  INFORMATIONAL
}

enum VulnerabilityCategory {
  ACCESS_CONTROL
  ARITHMETIC
  AUTHENTICATION
  CONFIGURATION
  CRYPTOGRAPHY
  DATA_EXPOSURE
  FLOW_CONTROL
  FRONT_RUNNING
  LOGIC_ERROR
  RACE_CONDITION
  REENTRANCY
  TIMESTAMP_DEPENDENCY
  UNCHECKED_CALL
  OTHER
}

enum FindingStatus {
  OPEN
  ACKNOWLEDGED
  REMEDIATED
  ACCEPTED_RISK
  DUPLICATE
  INVALID
}

model ReportAttachment {
  id          String    @id @default(cuid())
  reportId    String
  report      Report    @relation(fields: [reportId], references: [id], onDelete: Cascade)

  filename    String
  url         String
  type        String
  uploadedAt  DateTime  @default(now())

  @@index([reportId])
}

// ============================================================================
// PAYMENTS & BILLING
// ============================================================================

model Payment {
  id              String          @id @default(cuid())
  auditId         String
  audit           AuditRequest    @relation(fields: [auditId], references: [id], onDelete: Cascade)
  userId          String
  user            User            @relation(fields: [userId], references: [id])

  invoiceId       String
  invoice         Invoice         @relation(fields: [invoiceId], references: [id])

  amount          Decimal
  currency        String          @default("USD")
  status          PaymentStatus   @default(PENDING)
  method          PaymentMethod

  stripePaymentId String?         // Stripe payment intent ID
  stripeChargeId  String?         // Stripe charge ID

  failureReason   String?
  failureCount    Int             @default(0)
  nextRetry       DateTime?

  paidAt          DateTime?
  refundedAt      DateTime?

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([auditId])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentMethod {
  CREDIT_CARD
  ACH_TRANSFER
  WIRE_TRANSFER
  CHECK
  CRYPTO
}

model Invoice {
  id              String          @id @default(cuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id])

  invoiceNumber   String          @unique
  description     String?

  subtotal        Decimal
  tax             Decimal
  total           Decimal

  dueDate         DateTime
  sentAt          DateTime?
  paidAt          DateTime?

  status          InvoiceStatus   @default(DRAFT)
  notes           String?

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  lineItems       LineItem[]
  payments        Payment[]

  @@index([userId])
  @@index([status])
  @@index([dueDate])
}

enum InvoiceStatus {
  DRAFT
  SENT
  VIEWED
  PAID
  OVERDUE
  CANCELLED
}

model LineItem {
  id          String    @id @default(cuid())
  invoiceId   String
  invoice     Invoice   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  description String
  quantity    Int       @default(1)
  unitPrice   Decimal
  total       Decimal

  @@index([invoiceId])
}

// ============================================================================
// NOTIFICATIONS & ALERTS
// ============================================================================

model Notification {
  id              String            @id @default(cuid())
  userId          String?
  auditId         String?
  audit           AuditRequest?     @relation(fields: [auditId], references: [id], onDelete: SetNull)

  type            NotificationType
  title           String
  message         String
  data            Json?             // Additional data

  read            Boolean           @default(false)
  readAt          DateTime?

  sentVia         NotificationChannel[]

  createdAt       DateTime          @default(now())

  @@index([userId])
  @@index([auditId])
  @@index([read])
  @@index([createdAt])
}

enum NotificationType {
  AUDIT_CREATED
  AUDIT_APPROVED
  AUDIT_STARTED
  AUDIT_COMPLETED
  REPORT_READY
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  INVOICE_SENT
  TEAM_INVITE
  STATUS_UPDATE
  ALERT
}

enum NotificationChannel {
  EMAIL
  SMS
  WEBHOOK
  IN_APP
}

model NotificationSettings {
  id          String    @id @default(cuid())
  userId      String    @unique
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  emailAuditUpdates      Boolean @default(true)
  emailPaymentAlerts     Boolean @default(true)
  emailReportReady       Boolean @default(true)
  emailTeamInvites       Boolean @default(true)

  smsAuditUpdates        Boolean @default(false)
  smsPaymentAlerts       Boolean @default(true)

  dailyDigest            Boolean @default(false)
  frequencyPreference    String  @default("immediate")

  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
}

// ============================================================================
// WEBHOOKS & INTEGRATIONS
// ============================================================================

model WebhookEndpoint {
  id          String    @id @default(cuid())
  userId      String
  url         String
  events      String[]  // array of event types
  secret      String    // for signing requests
  active      Boolean   @default(true)
  retryCount  Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([active])
}

model WebhookEvent {
  id          String    @id @default(cuid())
  type        String
  payload     Json
  sentAt      DateTime
  status      String    @default("pending") // pending, sent, failed
  retries     Int       @default(0)
  lastError   String?
  createdAt   DateTime  @default(now())

  @@index([type])
  @@index([status])
  @@index([createdAt])
}

// ============================================================================
// AUDIT TRAIL & ACTIVITY LOGGING
// ============================================================================

model ActivityLog {
  id          String        @id @default(cuid())
  userId      String?
  user        User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  auditId     String?
  audit       AuditRequest? @relation("audit_activity", fields: [auditId], references: [id], onDelete: SetNull)

  action      String        // created, updated, deleted, etc
  entity      String        // User, AuditRequest, Report, etc
  entityId    String

  oldValues   Json?
  newValues   Json?

  ipAddress   String?
  userAgent   String?

  createdAt   DateTime      @default(now())

  @@index([userId])
  @@index([auditId])
  @@index([entity])
  @@index([createdAt])
}

// ============================================================================
// API & AUTHENTICATION KEYS
// ============================================================================

model ApiKey {
  id          String    @id @default(cuid())
  userId      String
  name        String
  key         String    @unique    // hashed
  lastUsedAt  DateTime?
  active      Boolean   @default(true)
  createdAt   DateTime  @default(now())
  expiresAt   DateTime?

  @@index([userId])
  @@index([active])
}

// ============================================================================
// SECURITY & COMPLIANCE
// ============================================================================

model SecurityAuditLog {
  id          String    @id @default(cuid())
  userId      String?
  action      String
  severity    String    // info, warning, critical
  details     String?
  ipAddress   String?
  createdAt   DateTime  @default(now())

  @@index([userId])
  @@index([severity])
  @@index([createdAt])
}

model ComplianceRecord {
  id          String    @id @default(cuid())
  auditId     String
  type        String    // SOC2, ISO27001, GDPR, etc
  status      String    // compliant, non-compliant, under_review
  notes       String?
  checkedAt   DateTime
  createdAt   DateTime  @default(now())

  @@index([auditId])
  @@index([type])
}
